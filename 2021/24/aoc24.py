class VM:

    def __init__(self, code, rules):
        self.code = code
        self.rules = rules

    def run(self, start_rule, stream):
        self.action = SemanticAction(None)
        self.pc = self.rules[start_rule]
        self.call_backtrack_stack = []
        self.stream, self.stream_rest = (stream, None)
        self.pos, self.pos_rest = (0, tuple())
        self.scope, self.scope_rest = (None, None)
        self.latest_fail_message, self.latest_fail_pos = (None, tuple())
        self.memo = {}
        while True:
            result = self.pop_arg()(self)
            if result:
                return result

    def pop_arg(self):
        code = self.code[self.pc]
        self.pc += 1
        return code

def PUSH_SCOPE(vm):
    vm.scope_rest = (vm.scope, vm.scope_rest)
    vm.scope = {}

def POP_SCOPE(vm):
    vm.scope, vm.scope_rest = vm.scope_rest

def BACKTRACK(vm):
    vm.call_backtrack_stack.append((
        vm.pop_arg(), vm.stream, vm.stream_rest, vm.pos, vm.pos_rest, vm.scope, vm.scope_rest
    ))

def COMMIT(vm):
    vm.call_backtrack_stack.pop()
    vm.pc = vm.pop_arg()

def CALL(vm):
    CALL_(vm, vm.pop_arg())

def CALL_(vm, pc):
    key = (pc, vm.pos_rest+(vm.pos,))
    if key in vm.memo:
        if vm.memo[key][0] is None:
            FAIL_(vm, vm.memo[key][1])
        else:
            vm.action, vm.stream, vm.stream_rest, vm.pos, vm.pos_rest = vm.memo[key]
    else:
        vm.call_backtrack_stack.append((vm.pc, key))
        vm.pc = pc

def RETURN(vm):
    if not vm.call_backtrack_stack:
        return vm.action
    vm.pc, key = vm.call_backtrack_stack.pop()
    vm.memo[key] = (vm.action, vm.stream, vm.stream_rest, vm.pos, vm.pos_rest)

def MATCH(vm):
    object_description = vm.pop_arg()
    fn = vm.pop_arg()
    MATCH_(vm, fn, ("expected {}", object_description))

def MATCH_(vm, fn, message):
    if vm.pos >= len(vm.stream) or not fn(vm.stream[vm.pos]):
        FAIL_(vm, message)
    else:
        vm.action = SemanticAction(vm.stream[vm.pos])
        vm.pos += 1
        return True

def MATCH_CALL_RULE(vm):
    if MATCH_(vm, lambda x: x in vm.rules, ("expected rule name",)):
        CALL_(vm, vm.rules[vm.action.value])

def LIST_START(vm):
    vm.scope_rest = (vm.scope, vm.scope_rest)
    vm.scope = []

def LIST_APPEND(vm):
    vm.scope.append(vm.action)

def LIST_END(vm):
    vm.action = SemanticAction(vm.scope, lambda self: [x.eval(self.runtime) for x in self.value])
    vm.scope, vm.scope_rest = vm.scope_rest

def BIND(vm):
    vm.scope[vm.pop_arg()] = vm.action

def ACTION(vm):
    vm.action = SemanticAction(vm.scope, vm.pop_arg())

def PUSH_STREAM(vm):
    if vm.pos >= len(vm.stream) or not isinstance(vm.stream[vm.pos], list):
        FAIL_(vm, ("expected list",))
    else:
        vm.stream_rest = (vm.stream, vm.stream_rest)
        vm.pos_rest = vm.pos_rest + (vm.pos,)
        vm.stream = vm.stream[vm.pos]
        vm.pos = 0

def POP_STREAM(vm):
    if vm.pos < len(vm.stream):
        FAIL_(vm, ("expected end of list",))
    else:
        vm.stream, vm.stream_rest = vm.stream_rest
        vm.pos, vm.pos_rest = vm.pos_rest[-1], vm.pos_rest[:-1]
        vm.pos += 1

def FAIL(vm):
    FAIL_(vm, (vm.pop_arg(),))

def FAIL_(vm, fail_message):
    fail_pos = vm.pos_rest+(vm.pos,)
    if fail_pos >= vm.latest_fail_pos:
        vm.latest_fail_message = fail_message
        vm.latest_fail_pos = fail_pos
    call_backtrack_entry = tuple()
    while vm.call_backtrack_stack:
        call_backtrack_entry = vm.call_backtrack_stack.pop()
        if len(call_backtrack_entry) == 7:
            break
        else:
            vm.memo[call_backtrack_entry[1]] = (None, fail_message)
    if len(call_backtrack_entry) != 7:
        raise MatchError(
            vm.latest_fail_message[0].format(*vm.latest_fail_message[1:]),
            vm.latest_fail_pos[-1],
            vm.stream
        )
    (vm.pc, vm.stream, vm.stream_rest, vm.pos, vm.pos_rest, vm.scope, vm.scope_rest) = call_backtrack_entry

class SemanticAction(object):

    def __init__(self, value, fn=lambda self: self.value):
        self.value = value
        self.fn = fn

    def eval(self, runtime):
        self.runtime = runtime
        return self.fn(self)

    def bind(self, name, value, continuation):
        self.runtime = self.runtime.set(name, value)
        return continuation()

    def lookup(self, name):
        if name in self.value:
            return self.value[name].eval(self.runtime)
        else:
            return self.runtime[name]

class MatchError(Exception):

    def __init__(self, message, pos, stream):
        Exception.__init__(self)
        self.message = message
        self.pos = pos
        self.stream = stream

class Grammar(object):

    def run(self, rule, stream, runtime={}):
        return Runtime(self, dict(runtime, **{
            "label": Counter(),
            "indentprefix": "    ",
            "list": list,
            "dict": dict,
            "int": int,
            "add": lambda x, y: x.append(y),
            "get": lambda x, y: x[y],
            "madd": lambda x, y: x + y,
            "mmod": lambda x, y: x % y,
            "mmul": lambda x, y: x * y,
            "meql": lambda x, y: 1 if x == y else 0,
            "mdiv": lambda x, y: x // y,
            "getdefault": lambda x, y, z: x.get(y, z),
            "set": lambda x, y, z: x.__setitem__(y, z),
            "len": len,
            "repr": repr,
            "join": join,
        })).run(rule, stream)

class Runtime(dict):

    def __init__(self, grammar, values):
        dict.__init__(self, dict(values, run=self.run))
        self.grammar = grammar

    def set(self, key, value):
        return Runtime(self.grammar, dict(self, **{key: value}))

    def run(self, rule, stream):
        return VM(self.grammar.code, self.grammar.rules).run(rule, stream).eval(self)

class Counter(object):

    def __init__(self):
        self.value = 0

    def __call__(self):
        result = self.value
        self.value += 1
        return result

def splice(depth, item):
    if depth == 0:
        return [item]
    else:
        return concat([splice(depth-1, subitem) for subitem in item])

def concat(lists):
    return [x for xs in lists for x in xs]

def join(items, delimiter=""):
    return delimiter.join(
        join(item, delimiter) if isinstance(item, list) else str(item)
        for item in items
    )

def indent(text, prefix="    "):
    return "".join(prefix+line for line in text.splitlines(True))

def compile_chain(grammars, source, debug=False):
    import sys
    import pprint
    for grammar, rule in grammars:
        try:
            source = grammar().run(rule, source)
            if debug:
                print(grammar.__name__)
                if isinstance(source, str):
                    print(source)
                else:
                    pprint.pprint(source)
        except MatchError as e:
            MARKER = "\033[0;31m<ERROR POSITION>\033[0m"
            if isinstance(e.stream, str):
                stream_string = e.stream[:e.pos] + MARKER + e.stream[e.pos:]
            else:
                stream_string = pprint.pformat(e.stream)
            sys.exit("ERROR: {}\nPOSITION: {}\nSTREAM:\n{}".format(
                e.message,
                e.pos,
                indent(stream_string)
            ))
    return source
class Parser(Grammar):
    rules = {
        'start': 0,
        'instruction': 25,
        'operand': 219,
        'digit': 264,
        'reg': 270
    }
    code = [
        PUSH_SCOPE,
        LIST_START,
        BACKTRACK,
        9,
        CALL,
        25,
        LIST_APPEND,
        COMMIT,
        2,
        LIST_END,
        BIND,
        'xs',
        BACKTRACK,
        21,
        MATCH,
        'any',
        lambda x: True,
        COMMIT,
        19,
        FAIL,
        'no match',
        ACTION,
        lambda self: self.lookup('xs'),
        POP_SCOPE,
        RETURN,
        BACKTRACK,
        52,
        PUSH_SCOPE,
        MATCH,
        'i',
        lambda x: x == 'i',
        MATCH,
        'n',
        lambda x: x == 'n',
        MATCH,
        'p',
        lambda x: x == 'p',
        MATCH,
        ' ',
        lambda x: x == ' ',
        CALL,
        270,
        BIND,
        'x',
        MATCH,
        '\n',
        lambda x: x == '\n',
        ACTION,
        lambda self: concat([splice(0, 'Inp'), splice(0, self.lookup('x'))]),
        POP_SCOPE,
        COMMIT,
        218,
        BACKTRACK,
        86,
        PUSH_SCOPE,
        MATCH,
        'a',
        lambda x: x == 'a',
        MATCH,
        'd',
        lambda x: x == 'd',
        MATCH,
        'd',
        lambda x: x == 'd',
        MATCH,
        ' ',
        lambda x: x == ' ',
        CALL,
        270,
        BIND,
        'x',
        MATCH,
        ' ',
        lambda x: x == ' ',
        CALL,
        219,
        BIND,
        'y',
        MATCH,
        '\n',
        lambda x: x == '\n',
        ACTION,
        lambda self: concat([splice(0, 'Add'), splice(0, self.lookup('x')), splice(0, self.lookup('y'))]),
        POP_SCOPE,
        COMMIT,
        218,
        BACKTRACK,
        120,
        PUSH_SCOPE,
        MATCH,
        'm',
        lambda x: x == 'm',
        MATCH,
        'u',
        lambda x: x == 'u',
        MATCH,
        'l',
        lambda x: x == 'l',
        MATCH,
        ' ',
        lambda x: x == ' ',
        CALL,
        270,
        BIND,
        'x',
        MATCH,
        ' ',
        lambda x: x == ' ',
        CALL,
        219,
        BIND,
        'y',
        MATCH,
        '\n',
        lambda x: x == '\n',
        ACTION,
        lambda self: concat([splice(0, 'Mul'), splice(0, self.lookup('x')), splice(0, self.lookup('y'))]),
        POP_SCOPE,
        COMMIT,
        218,
        BACKTRACK,
        154,
        PUSH_SCOPE,
        MATCH,
        'd',
        lambda x: x == 'd',
        MATCH,
        'i',
        lambda x: x == 'i',
        MATCH,
        'v',
        lambda x: x == 'v',
        MATCH,
        ' ',
        lambda x: x == ' ',
        CALL,
        270,
        BIND,
        'x',
        MATCH,
        ' ',
        lambda x: x == ' ',
        CALL,
        219,
        BIND,
        'y',
        MATCH,
        '\n',
        lambda x: x == '\n',
        ACTION,
        lambda self: concat([splice(0, 'Div'), splice(0, self.lookup('x')), splice(0, self.lookup('y'))]),
        POP_SCOPE,
        COMMIT,
        218,
        BACKTRACK,
        188,
        PUSH_SCOPE,
        MATCH,
        'm',
        lambda x: x == 'm',
        MATCH,
        'o',
        lambda x: x == 'o',
        MATCH,
        'd',
        lambda x: x == 'd',
        MATCH,
        ' ',
        lambda x: x == ' ',
        CALL,
        270,
        BIND,
        'x',
        MATCH,
        ' ',
        lambda x: x == ' ',
        CALL,
        219,
        BIND,
        'y',
        MATCH,
        '\n',
        lambda x: x == '\n',
        ACTION,
        lambda self: concat([splice(0, 'Mod'), splice(0, self.lookup('x')), splice(0, self.lookup('y'))]),
        POP_SCOPE,
        COMMIT,
        218,
        PUSH_SCOPE,
        MATCH,
        'e',
        lambda x: x == 'e',
        MATCH,
        'q',
        lambda x: x == 'q',
        MATCH,
        'l',
        lambda x: x == 'l',
        MATCH,
        ' ',
        lambda x: x == ' ',
        CALL,
        270,
        BIND,
        'x',
        MATCH,
        ' ',
        lambda x: x == ' ',
        CALL,
        219,
        BIND,
        'y',
        MATCH,
        '\n',
        lambda x: x == '\n',
        ACTION,
        lambda self: concat([splice(0, 'Eql'), splice(0, self.lookup('x')), splice(0, self.lookup('y'))]),
        POP_SCOPE,
        RETURN,
        BACKTRACK,
        231,
        PUSH_SCOPE,
        CALL,
        270,
        BIND,
        'x',
        ACTION,
        lambda self: concat([splice(0, 'Reg'), splice(0, self.lookup('x'))]),
        POP_SCOPE,
        COMMIT,
        263,
        PUSH_SCOPE,
        BACKTRACK,
        241,
        PUSH_SCOPE,
        MATCH,
        '-',
        lambda x: x == '-',
        POP_SCOPE,
        COMMIT,
        243,
        PUSH_SCOPE,
        POP_SCOPE,
        BIND,
        'x',
        CALL,
        264,
        BIND,
        'y',
        LIST_START,
        BACKTRACK,
        257,
        CALL,
        264,
        LIST_APPEND,
        COMMIT,
        250,
        LIST_END,
        BIND,
        'ys',
        ACTION,
        lambda self: concat([splice(0, 'Num'), splice(0, self.lookup('int')(join([self.lookup('x'), self.lookup('y'), self.lookup('ys')])))]),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        MATCH,
        "range '0'-'9'",
        lambda x: '0' <= x <= '9',
        POP_SCOPE,
        RETURN,
        BACKTRACK,
        279,
        PUSH_SCOPE,
        MATCH,
        'w',
        lambda x: x == 'w',
        POP_SCOPE,
        COMMIT,
        302,
        BACKTRACK,
        288,
        PUSH_SCOPE,
        MATCH,
        'x',
        lambda x: x == 'x',
        POP_SCOPE,
        COMMIT,
        302,
        BACKTRACK,
        297,
        PUSH_SCOPE,
        MATCH,
        'y',
        lambda x: x == 'y',
        POP_SCOPE,
        COMMIT,
        302,
        PUSH_SCOPE,
        MATCH,
        'z',
        lambda x: x == 'z',
        POP_SCOPE,
        RETURN
    ]
class ToExpression(Grammar):
    rules = {
        'start': 0,
        'statement': 25,
        'foo': 64
    }
    code = [
        PUSH_SCOPE,
        LIST_START,
        BACKTRACK,
        9,
        CALL,
        25,
        LIST_APPEND,
        COMMIT,
        2,
        LIST_END,
        BIND,
        'xs',
        BACKTRACK,
        21,
        MATCH,
        'any',
        lambda x: True,
        COMMIT,
        19,
        FAIL,
        'no match',
        ACTION,
        lambda self: self.bind('regs', self.lookup('dict')(), lambda: self.bind('', self.lookup('set')(self.lookup('regs'), 'w', concat([splice(0, 'Num'), splice(0, 0)])), lambda: self.bind('', self.lookup('set')(self.lookup('regs'), 'x', concat([splice(0, 'Num'), splice(0, 0)])), lambda: self.bind('', self.lookup('set')(self.lookup('regs'), 'y', concat([splice(0, 'Num'), splice(0, 0)])), lambda: self.bind('', self.lookup('set')(self.lookup('regs'), 'z', concat([splice(0, 'Num'), splice(0, 0)])), lambda: concat([splice(2, self.lookup('xs')), splice(0, concat([splice(0, 'Set'), splice(0, 'z'), splice(0, self.lookup('get')(self.lookup('regs'), 'z'))]))])))))),
        POP_SCOPE,
        RETURN,
        BACKTRACK,
        43,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Inp',
        lambda x: x == 'Inp',
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'r',
        POP_STREAM,
        ACTION,
        lambda self: self.bind('', self.lookup('set')(self.lookup('regs'), self.lookup('r'), concat([splice(0, 'Inp'), splice(0, self.lookup('label')())])), lambda: concat([])),
        POP_SCOPE,
        COMMIT,
        63,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'op',
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'r',
        CALL,
        64,
        BIND,
        'y',
        POP_STREAM,
        ACTION,
        lambda self: self.bind('tmp', concat([splice(0, 'Tmp'), splice(0, self.lookup('label')())]), lambda: self.bind('left', self.lookup('get')(self.lookup('regs'), self.lookup('r')), lambda: self.bind('right', self.lookup('y'), lambda: self.bind('', self.lookup('set')(self.lookup('regs'), self.lookup('r'), self.lookup('tmp')), lambda: concat([splice(0, concat([splice(0, 'Set'), splice(0, self.lookup('tmp')), splice(0, concat([splice(0, self.lookup('op')), splice(0, self.lookup('left')), splice(0, self.lookup('right'))]))]))]))))),
        POP_SCOPE,
        RETURN,
        BACKTRACK,
        82,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Reg',
        lambda x: x == 'Reg',
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'r',
        POP_STREAM,
        ACTION,
        lambda self: self.lookup('get')(self.lookup('regs'), self.lookup('r')),
        POP_SCOPE,
        COMMIT,
        87,
        PUSH_SCOPE,
        MATCH,
        'any',
        lambda x: True,
        POP_SCOPE,
        RETURN
    ]
class Pretty(Grammar):
    rules = {
        'start': 0,
        'pretty': 25
    }
    code = [
        PUSH_SCOPE,
        LIST_START,
        BACKTRACK,
        9,
        CALL,
        25,
        LIST_APPEND,
        COMMIT,
        2,
        LIST_END,
        BIND,
        'xs',
        BACKTRACK,
        21,
        MATCH,
        'any',
        lambda x: True,
        COMMIT,
        19,
        FAIL,
        'no match',
        ACTION,
        lambda self: join([self.lookup('xs')]),
        POP_SCOPE,
        RETURN,
        BACKTRACK,
        47,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Set',
        lambda x: x == 'Set',
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        CALL,
        25,
        BIND,
        'y',
        POP_STREAM,
        ACTION,
        lambda self: join([self.lookup('x'), ' = ', self.lookup('y'), '\n']),
        POP_SCOPE,
        COMMIT,
        175,
        BACKTRACK,
        68,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Add',
        lambda x: x == 'Add',
        CALL,
        25,
        BIND,
        'x',
        CALL,
        25,
        BIND,
        'y',
        POP_STREAM,
        ACTION,
        lambda self: join(['(', self.lookup('x'), ' + ', self.lookup('y'), ')']),
        POP_SCOPE,
        COMMIT,
        175,
        BACKTRACK,
        89,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Mul',
        lambda x: x == 'Mul',
        CALL,
        25,
        BIND,
        'x',
        CALL,
        25,
        BIND,
        'y',
        POP_STREAM,
        ACTION,
        lambda self: join(['(', self.lookup('x'), ' * ', self.lookup('y'), ')']),
        POP_SCOPE,
        COMMIT,
        175,
        BACKTRACK,
        110,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Div',
        lambda x: x == 'Div',
        CALL,
        25,
        BIND,
        'x',
        CALL,
        25,
        BIND,
        'y',
        POP_STREAM,
        ACTION,
        lambda self: join(['(', self.lookup('x'), ' / ', self.lookup('y'), ')']),
        POP_SCOPE,
        COMMIT,
        175,
        BACKTRACK,
        131,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Mod',
        lambda x: x == 'Mod',
        CALL,
        25,
        BIND,
        'x',
        CALL,
        25,
        BIND,
        'y',
        POP_STREAM,
        ACTION,
        lambda self: join(['(', self.lookup('x'), ' % ', self.lookup('y'), ')']),
        POP_SCOPE,
        COMMIT,
        175,
        BACKTRACK,
        152,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Eql',
        lambda x: x == 'Eql',
        CALL,
        25,
        BIND,
        'x',
        CALL,
        25,
        BIND,
        'y',
        POP_STREAM,
        ACTION,
        lambda self: join(['(', self.lookup('x'), ' == ', self.lookup('y'), ')']),
        POP_SCOPE,
        COMMIT,
        175,
        BACKTRACK,
        170,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Num',
        lambda x: x == 'Num',
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        POP_STREAM,
        ACTION,
        lambda self: self.lookup('x'),
        POP_SCOPE,
        COMMIT,
        175,
        PUSH_SCOPE,
        MATCH,
        'any',
        lambda x: True,
        POP_SCOPE,
        RETURN
    ]
class Simplify(Grammar):
    rules = {
        'start': 0,
        'simplify': 25,
        'large': 487
    }
    code = [
        PUSH_SCOPE,
        LIST_START,
        BACKTRACK,
        9,
        CALL,
        25,
        LIST_APPEND,
        COMMIT,
        2,
        LIST_END,
        BIND,
        'xs',
        BACKTRACK,
        21,
        MATCH,
        'any',
        lambda x: True,
        COMMIT,
        19,
        FAIL,
        'no match',
        ACTION,
        lambda self: self.lookup('xs'),
        POP_SCOPE,
        RETURN,
        BACKTRACK,
        47,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Set',
        lambda x: x == 'Set',
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        CALL,
        25,
        BIND,
        'y',
        POP_STREAM,
        ACTION,
        lambda self: concat([splice(0, 'Set'), splice(0, self.lookup('x')), splice(0, self.lookup('y'))]),
        POP_SCOPE,
        COMMIT,
        486,
        BACKTRACK,
        72,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Mul',
        lambda x: x == 'Mul',
        PUSH_STREAM,
        MATCH,
        'Num',
        lambda x: x == 'Num',
        MATCH,
        0,
        lambda x: x == 0,
        POP_STREAM,
        CALL,
        25,
        BIND,
        'x',
        POP_STREAM,
        ACTION,
        lambda self: self.lookup('x'),
        POP_SCOPE,
        COMMIT,
        486,
        BACKTRACK,
        97,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Mul',
        lambda x: x == 'Mul',
        CALL,
        25,
        BIND,
        'x',
        PUSH_STREAM,
        MATCH,
        'Num',
        lambda x: x == 'Num',
        MATCH,
        0,
        lambda x: x == 0,
        POP_STREAM,
        POP_STREAM,
        ACTION,
        lambda self: self.lookup('x'),
        POP_SCOPE,
        COMMIT,
        486,
        BACKTRACK,
        130,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Mul',
        lambda x: x == 'Mul',
        PUSH_STREAM,
        MATCH,
        'Num',
        lambda x: x == 'Num',
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        POP_STREAM,
        PUSH_STREAM,
        MATCH,
        'Num',
        lambda x: x == 'Num',
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'y',
        POP_STREAM,
        POP_STREAM,
        ACTION,
        lambda self: concat([splice(0, 'Num'), splice(0, self.lookup('mmul')(self.lookup('x'), self.lookup('y')))]),
        POP_SCOPE,
        COMMIT,
        486,
        BACKTRACK,
        163,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Add',
        lambda x: x == 'Add',
        PUSH_STREAM,
        MATCH,
        'Num',
        lambda x: x == 'Num',
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        POP_STREAM,
        PUSH_STREAM,
        MATCH,
        'Num',
        lambda x: x == 'Num',
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'y',
        POP_STREAM,
        POP_STREAM,
        ACTION,
        lambda self: concat([splice(0, 'Num'), splice(0, self.lookup('madd')(self.lookup('x'), self.lookup('y')))]),
        POP_SCOPE,
        COMMIT,
        486,
        BACKTRACK,
        196,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Mod',
        lambda x: x == 'Mod',
        PUSH_STREAM,
        MATCH,
        'Num',
        lambda x: x == 'Num',
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        POP_STREAM,
        PUSH_STREAM,
        MATCH,
        'Num',
        lambda x: x == 'Num',
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'y',
        POP_STREAM,
        POP_STREAM,
        ACTION,
        lambda self: concat([splice(0, 'Num'), splice(0, self.lookup('mmod')(self.lookup('x'), self.lookup('y')))]),
        POP_SCOPE,
        COMMIT,
        486,
        BACKTRACK,
        221,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Add',
        lambda x: x == 'Add',
        CALL,
        25,
        BIND,
        'x',
        PUSH_STREAM,
        MATCH,
        'Num',
        lambda x: x == 'Num',
        MATCH,
        0,
        lambda x: x == 0,
        POP_STREAM,
        POP_STREAM,
        ACTION,
        lambda self: self.lookup('x'),
        POP_SCOPE,
        COMMIT,
        486,
        BACKTRACK,
        254,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Add',
        lambda x: x == 'Add',
        PUSH_STREAM,
        MATCH,
        'Num',
        lambda x: x == 'Num',
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        POP_STREAM,
        PUSH_STREAM,
        MATCH,
        'Num',
        lambda x: x == 'Num',
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'y',
        POP_STREAM,
        POP_STREAM,
        ACTION,
        lambda self: concat([splice(0, 'Num'), splice(0, self.lookup('madd')(self.lookup('x'), self.lookup('y')))]),
        POP_SCOPE,
        COMMIT,
        486,
        BACKTRACK,
        279,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Div',
        lambda x: x == 'Div',
        CALL,
        25,
        BIND,
        'x',
        PUSH_STREAM,
        MATCH,
        'Num',
        lambda x: x == 'Num',
        MATCH,
        1,
        lambda x: x == 1,
        POP_STREAM,
        POP_STREAM,
        ACTION,
        lambda self: self.lookup('x'),
        POP_SCOPE,
        COMMIT,
        486,
        BACKTRACK,
        302,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Eql',
        lambda x: x == 'Eql',
        CALL,
        487,
        PUSH_STREAM,
        MATCH,
        'Inp',
        lambda x: x == 'Inp',
        MATCH,
        'any',
        lambda x: True,
        POP_STREAM,
        POP_STREAM,
        ACTION,
        lambda self: concat([splice(0, 'Num'), splice(0, 0)]),
        POP_SCOPE,
        COMMIT,
        486,
        BACKTRACK,
        331,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Eql',
        lambda x: x == 'Eql',
        PUSH_STREAM,
        MATCH,
        'Num',
        lambda x: x == 'Num',
        MATCH,
        0,
        lambda x: x == 0,
        POP_STREAM,
        PUSH_STREAM,
        MATCH,
        'Num',
        lambda x: x == 'Num',
        MATCH,
        0,
        lambda x: x == 0,
        POP_STREAM,
        POP_STREAM,
        ACTION,
        lambda self: concat([splice(0, 'Num'), splice(0, 1)]),
        POP_SCOPE,
        COMMIT,
        486,
        BACKTRACK,
        352,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Add',
        lambda x: x == 'Add',
        CALL,
        25,
        BIND,
        'x',
        CALL,
        25,
        BIND,
        'y',
        POP_STREAM,
        ACTION,
        lambda self: concat([splice(0, 'Add'), splice(0, self.lookup('x')), splice(0, self.lookup('y'))]),
        POP_SCOPE,
        COMMIT,
        486,
        BACKTRACK,
        373,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Mul',
        lambda x: x == 'Mul',
        CALL,
        25,
        BIND,
        'x',
        CALL,
        25,
        BIND,
        'y',
        POP_STREAM,
        ACTION,
        lambda self: concat([splice(0, 'Mul'), splice(0, self.lookup('x')), splice(0, self.lookup('y'))]),
        POP_SCOPE,
        COMMIT,
        486,
        BACKTRACK,
        394,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Div',
        lambda x: x == 'Div',
        CALL,
        25,
        BIND,
        'x',
        CALL,
        25,
        BIND,
        'y',
        POP_STREAM,
        ACTION,
        lambda self: concat([splice(0, 'Div'), splice(0, self.lookup('x')), splice(0, self.lookup('y'))]),
        POP_SCOPE,
        COMMIT,
        486,
        BACKTRACK,
        415,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Mod',
        lambda x: x == 'Mod',
        CALL,
        25,
        BIND,
        'x',
        CALL,
        25,
        BIND,
        'y',
        POP_STREAM,
        ACTION,
        lambda self: concat([splice(0, 'Mod'), splice(0, self.lookup('x')), splice(0, self.lookup('y'))]),
        POP_SCOPE,
        COMMIT,
        486,
        BACKTRACK,
        436,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Eql',
        lambda x: x == 'Eql',
        CALL,
        25,
        BIND,
        'x',
        CALL,
        25,
        BIND,
        'y',
        POP_STREAM,
        ACTION,
        lambda self: concat([splice(0, 'Eql'), splice(0, self.lookup('x')), splice(0, self.lookup('y'))]),
        POP_SCOPE,
        COMMIT,
        486,
        BACKTRACK,
        454,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Num',
        lambda x: x == 'Num',
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        POP_STREAM,
        ACTION,
        lambda self: concat([splice(0, 'Num'), splice(0, self.lookup('x'))]),
        POP_SCOPE,
        COMMIT,
        486,
        BACKTRACK,
        472,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Tmp',
        lambda x: x == 'Tmp',
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        POP_STREAM,
        ACTION,
        lambda self: concat([splice(0, 'Tmp'), splice(0, self.lookup('x'))]),
        POP_SCOPE,
        COMMIT,
        486,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Inp',
        lambda x: x == 'Inp',
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        POP_STREAM,
        ACTION,
        lambda self: concat([splice(0, 'Inp'), splice(0, self.lookup('x'))]),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Num',
        lambda x: x == 'Num',
        MATCH,
        10,
        lambda x: x == 10,
        POP_STREAM,
        POP_SCOPE,
        RETURN
    ]
class Expand(Grammar):
    rules = {
        'start': 0,
        'record': 25,
        'expandx': 45,
        'expand': 57
    }
    code = [
        PUSH_SCOPE,
        LIST_START,
        BACKTRACK,
        9,
        CALL,
        25,
        LIST_APPEND,
        COMMIT,
        2,
        LIST_END,
        BIND,
        'xs',
        BACKTRACK,
        21,
        MATCH,
        'any',
        lambda x: True,
        COMMIT,
        19,
        FAIL,
        'no match',
        ACTION,
        lambda self: self.bind('vars', self.lookup('dict')(), lambda: self.lookup('run')('expandx', self.lookup('xs'))),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Set',
        lambda x: x == 'Set',
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'y',
        POP_STREAM,
        ACTION,
        lambda self: self.bind('', self.lookup('set')(self.lookup('vars'), join([self.lookup('x')]), self.lookup('y')), lambda: concat([splice(0, 'Set'), splice(0, self.lookup('x')), splice(0, self.lookup('y'))])),
        POP_SCOPE,
        RETURN,
        PUSH_SCOPE,
        LIST_START,
        BACKTRACK,
        54,
        CALL,
        57,
        LIST_APPEND,
        COMMIT,
        47,
        LIST_END,
        POP_SCOPE,
        RETURN,
        BACKTRACK,
        79,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Set',
        lambda x: x == 'Set',
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        CALL,
        57,
        BIND,
        'y',
        POP_STREAM,
        ACTION,
        lambda self: concat([splice(0, 'Set'), splice(0, self.lookup('x')), splice(0, self.lookup('y'))]),
        POP_SCOPE,
        COMMIT,
        207,
        BACKTRACK,
        100,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Add',
        lambda x: x == 'Add',
        CALL,
        57,
        BIND,
        'x',
        CALL,
        57,
        BIND,
        'y',
        POP_STREAM,
        ACTION,
        lambda self: concat([splice(0, 'Add'), splice(0, self.lookup('x')), splice(0, self.lookup('y'))]),
        POP_SCOPE,
        COMMIT,
        207,
        BACKTRACK,
        121,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Mul',
        lambda x: x == 'Mul',
        CALL,
        57,
        BIND,
        'x',
        CALL,
        57,
        BIND,
        'y',
        POP_STREAM,
        ACTION,
        lambda self: concat([splice(0, 'Mul'), splice(0, self.lookup('x')), splice(0, self.lookup('y'))]),
        POP_SCOPE,
        COMMIT,
        207,
        BACKTRACK,
        142,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Div',
        lambda x: x == 'Div',
        CALL,
        57,
        BIND,
        'x',
        CALL,
        57,
        BIND,
        'y',
        POP_STREAM,
        ACTION,
        lambda self: concat([splice(0, 'Div'), splice(0, self.lookup('x')), splice(0, self.lookup('y'))]),
        POP_SCOPE,
        COMMIT,
        207,
        BACKTRACK,
        163,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Mod',
        lambda x: x == 'Mod',
        CALL,
        57,
        BIND,
        'x',
        CALL,
        57,
        BIND,
        'y',
        POP_STREAM,
        ACTION,
        lambda self: concat([splice(0, 'Mod'), splice(0, self.lookup('x')), splice(0, self.lookup('y'))]),
        POP_SCOPE,
        COMMIT,
        207,
        BACKTRACK,
        184,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Eql',
        lambda x: x == 'Eql',
        CALL,
        57,
        BIND,
        'x',
        CALL,
        57,
        BIND,
        'y',
        POP_STREAM,
        ACTION,
        lambda self: concat([splice(0, 'Eql'), splice(0, self.lookup('x')), splice(0, self.lookup('y'))]),
        POP_SCOPE,
        COMMIT,
        207,
        BACKTRACK,
        202,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Tmp',
        lambda x: x == 'Tmp',
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        POP_STREAM,
        ACTION,
        lambda self: self.lookup('get')(self.lookup('vars'), join(['Tmp', self.lookup('x')])),
        POP_SCOPE,
        COMMIT,
        207,
        PUSH_SCOPE,
        MATCH,
        'any',
        lambda x: True,
        POP_SCOPE,
        RETURN
    ]
class RemoveUnusedTmps(Grammar):
    rules = {
        'start': 0,
        'analyze': 25
    }
    code = [
        PUSH_SCOPE,
        LIST_START,
        BACKTRACK,
        9,
        CALL,
        25,
        LIST_APPEND,
        COMMIT,
        2,
        LIST_END,
        BIND,
        'xs',
        BACKTRACK,
        21,
        MATCH,
        'any',
        lambda x: True,
        COMMIT,
        19,
        FAIL,
        'no match',
        ACTION,
        lambda self: self.bind('sets', self.lookup('dict')(), lambda: self.bind('used', self.lookup('list')(), lambda: self.bind('', self.lookup('xs'), lambda: self.bind('', self.lookup('add')(self.lookup('used'), self.lookup('get')(self.lookup('sets'), 'z')), lambda: self.lookup('used'))))),
        POP_SCOPE,
        RETURN,
        BACKTRACK,
        47,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Set',
        lambda x: x == 'Set',
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        CALL,
        25,
        BIND,
        'y',
        POP_STREAM,
        ACTION,
        lambda self: self.lookup('set')(self.lookup('sets'), join([self.lookup('x')]), concat([splice(0, 'Set'), splice(0, self.lookup('x')), splice(0, self.lookup('y'))])),
        POP_SCOPE,
        COMMIT,
        175,
        BACKTRACK,
        68,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Add',
        lambda x: x == 'Add',
        CALL,
        25,
        BIND,
        'x',
        CALL,
        25,
        BIND,
        'y',
        POP_STREAM,
        ACTION,
        lambda self: concat([splice(0, 'Add'), splice(0, self.lookup('x')), splice(0, self.lookup('y'))]),
        POP_SCOPE,
        COMMIT,
        175,
        BACKTRACK,
        89,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Mul',
        lambda x: x == 'Mul',
        CALL,
        25,
        BIND,
        'x',
        CALL,
        25,
        BIND,
        'y',
        POP_STREAM,
        ACTION,
        lambda self: concat([splice(0, 'Mul'), splice(0, self.lookup('x')), splice(0, self.lookup('y'))]),
        POP_SCOPE,
        COMMIT,
        175,
        BACKTRACK,
        110,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Div',
        lambda x: x == 'Div',
        CALL,
        25,
        BIND,
        'x',
        CALL,
        25,
        BIND,
        'y',
        POP_STREAM,
        ACTION,
        lambda self: concat([splice(0, 'Div'), splice(0, self.lookup('x')), splice(0, self.lookup('y'))]),
        POP_SCOPE,
        COMMIT,
        175,
        BACKTRACK,
        131,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Mod',
        lambda x: x == 'Mod',
        CALL,
        25,
        BIND,
        'x',
        CALL,
        25,
        BIND,
        'y',
        POP_STREAM,
        ACTION,
        lambda self: concat([splice(0, 'Mod'), splice(0, self.lookup('x')), splice(0, self.lookup('y'))]),
        POP_SCOPE,
        COMMIT,
        175,
        BACKTRACK,
        152,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Eql',
        lambda x: x == 'Eql',
        CALL,
        25,
        BIND,
        'x',
        CALL,
        25,
        BIND,
        'y',
        POP_STREAM,
        ACTION,
        lambda self: concat([splice(0, 'Eql'), splice(0, self.lookup('x')), splice(0, self.lookup('y'))]),
        POP_SCOPE,
        COMMIT,
        175,
        BACKTRACK,
        170,
        PUSH_SCOPE,
        PUSH_STREAM,
        MATCH,
        'Tmp',
        lambda x: x == 'Tmp',
        MATCH,
        'any',
        lambda x: True,
        BIND,
        'x',
        POP_STREAM,
        ACTION,
        lambda self: self.bind('', self.lookup('add')(self.lookup('used'), self.lookup('get')(self.lookup('sets'), join(['Tmp', self.lookup('x')]))), lambda: concat([splice(0, 'Tmp'), splice(0, self.lookup('x'))])),
        POP_SCOPE,
        COMMIT,
        175,
        PUSH_SCOPE,
        MATCH,
        'any',
        lambda x: True,
        POP_SCOPE,
        RETURN
    ]
if __name__ == "__main__":
    with open("input") as f:
        compile_chain([
            (Parser, "start"),
            (ToExpression, "start"),
            (Simplify, "start"),

            (Expand, "start"),
            (Simplify, "start"),
            (Simplify, "start"),
            (Simplify, "start"),

            (Expand, "start"),
            (Simplify, "start"),
            (Simplify, "start"),
            (Simplify, "start"),

            (Expand, "start"),
            (Simplify, "start"),
            (Simplify, "start"),
            (Simplify, "start"),
            (Simplify, "start"),

            #(RemoveUnusedTmps, "start"),
            (Pretty, "start"),
        ], f.read(), debug=True)
